{
  haskellLanguagePragmas = "{-# LANGUAGE BlockArguments #-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE ExtendedDefaultRules #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-type-defaults #-}\n";
  programs = {
    calendar-notify = {
      libraries = ["aeson" "bytestring" "chronos" "deepseq" "shh" "text" "torsor"];
      loadFromBins = ["khal" "libnotify" "coreutils" "mpv"];
      name = "calendar-notify";
      text = "module Main where\n\nimport qualified Chronos\nimport Control.DeepSeq (NFData)\nimport qualified Data.Aeson as Aeson\nimport Data.Bool (bool)\nimport qualified Data.ByteString.Lazy as BS\nimport Data.Foldable (traverse_)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport GHC.Generics (Generic)\nimport Shh\nimport qualified Torsor\n\n$(loadEnv SearchPath)\n\nmain :: IO ()\nmain = do\n  khal \"list\" \"--notstarted\" \"--json\" \"title\" \"--json\" \"start\" \"--json\" \"calendar\" \"today\" \"today\"\n    |> readInput (pure . Aeson.decode @[CalendarEntry])\n    >>= maybe (print \"cannot parse khal output\") (traverse_ go)\n  where\n    go :: CalendarEntry -> IO ()\n    go entry = do\n      now <-\n        date \"+%d/%m/%Y %T\"\n          |> readInput\n            ( maybe (error \"cannot determine system time\") pure\n                . Chronos.decode_DmyHMS_opt_S_lenient\n                . T.decodeUtf8Lenient\n                . BS.toStrict\n                . trim\n            )\n      case Chronos.decode_DmyHMS_opt_S_lenient . T.pack . start $ entry of\n        Nothing -> pure ()\n        Just when -> bool mempty (notify entry) . shouldNotify when $ now\n\nshouldNotify :: Chronos.Datetime -> Chronos.Datetime -> Bool\nshouldNotify event now =\n  let\n    fifteenMinutes = Torsor.scale 15 Chronos.minute\n    eventTime = Chronos.datetimeToTime event\n    nowTime = Chronos.datetimeToTime now\n    diff = Torsor.difference eventTime (Torsor.add fifteenMinutes nowTime)\n  in\n    diff < Chronos.minute && diff >= mempty\n\ndata CalendarEntry = CalendarEntry\n  { start :: String\n  , title :: String\n  , calendar :: String\n  }\n  deriving stock (Generic, Show)\n  deriving anyclass (NFData, Aeson.ToJSON, Aeson.FromJSON)\n\nnotify :: CalendarEntry -> IO ()\nnotify CalendarEntry {..} = do\n  notify_send \"-a\" \"calendar-notify\" (title <> \" at \" <> start)\n  mpv \" --terminal=no\" \"~/.config/swaync/sounds/calendar.mp3\"\n";
    };
    calendar-status = {
      libraries = ["aeson" "bytestring" "chronos" "deepseq" "shh" "text" "torsor"];
      loadFromBins = ["khal" "libnotify" "coreutils" "mpv"];
      name = "calendar-status";
      text = "module Main where\n\nimport qualified Chronos\nimport Control.Monad (when)\nimport qualified Control.Monad.State as S\nimport Data.Aeson ((.=))\nimport qualified Data.Aeson as Aeson\nimport Data.Bool (bool)\nimport qualified Data.ByteString.Lazy.Char8 as BS\nimport Data.Foldable (foldlM)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Data.Text.Lazy (Text)\nimport qualified Data.Text.Lazy as TL\nimport qualified Data.Text.Lazy.Encoding as TL\nimport Shh\nimport qualified Torsor\n\n$(loadEnv SearchPath)\n\nmain :: IO ()\nmain = do\n  today <- getToday\n  let\n    nextWeek = Chronos.timeToDatetime . Torsor.add (Torsor.scale 7 Chronos.day) . Chronos.datetimeToTime $ today\n\n  khal\n    \"list\"\n    \"--format\"\n    \"[{calendar}] {cancelled}{start-end-time-style} {title}{repeat-symbol}\"\n    \"now\"\n    (T.unpack . Chronos.encode_Dmy (Just '/') . Chronos.datetimeDate $ nextWeek)\n    |> readInputLines printJsonSummary\n\nprintJsonSummary :: [BS.ByteString] -> IO ()\nprintJsonSummary input =\n  writeOutput\n    . Aeson.encode\n    . Aeson.object\n    $ [ \"text\" .= text\n      , \"alt\" .= \"\"\n      , \"tooltip\" .= tooltip\n      , \"class\"\n          .= if text == \"\\61747\"\n            then \"today\"\n            else \"none\"\n      ]\n where\n  text :: Text\n  text =\n    case TL.words tooltip of\n      (\"Today,\" : _) -> S.evalState (go . drop 1 . TL.lines $ tooltip) \"\\61747\"\n      _ -> \"\\61747\"\n\n  go :: [Text] -> S.State Text Text\n  go = \\case -- ⟳\n    (x:xs) ->\n      if | (fst <$> TL.uncons x) /= Just '[' ->  S.get\n         | '↔' `TL.elem` x  -> S.modify (\\st -> (\"\\61555 \" <>) . skipCalendar . bool st x . TL.elem '↔' $ st) *> go xs\n         | '⟳' `TL.elem` x  -> S.put (\"\\61555 \" <> skipCalendar x) *> go xs\n         | otherwise        -> pure (\"\\61555 \" <> skipCalendar x)\n    [] -> S.get\n\n  skipCalendar :: Text -> Text\n  skipCalendar e = case TL.words e of\n                     [] -> e\n                     [single] -> single\n                     (_cal:rest) -> TL.unwords rest\n\n  tooltip :: Text\n  tooltip =\n    TL.strip\n      . flip S.evalState []\n      . foldlM parseLine TL.empty\n      . fmap TL.decodeUtf8\n      $ input\n\n  parseLine :: Text -> Text -> S.State [Text] Text\n  parseLine acc bs =\n    case TL.head bs of\n      '[' ->\n        S.gets (bs `elem`) >>= \\case\n          True -> pure acc\n          False -> do\n            when (TL.elem '↔' bs) $ S.modify (<> [bs])\n            pure $ acc <> replaceCalendarNames bs <> \"\\n\"\n      _ -> pure $ acc <> \"\\n\" <> bs <> \"\\n\"\n\n  replaceCalendarNames :: Text -> Text\n  replaceCalendarNames =\n    TL.replace \"s810p67l2bi1168j8luka5nic0@group.calendar.google.com\" \"Every\"\n      . TL.replace \"alexaeviest@gmail.com\" \"gmail\"\n\ngetToday :: IO Chronos.Datetime\ngetToday =\n  date \"+%d/%m/%Y %R\"\n    |> readInput\n      ( maybe (error \"cannot determine system time\") pure\n          . Chronos.decode_DmyHMS_opt_S_lenient\n          . T.decodeUtf8Lenient\n          . BS.toStrict\n          . trim\n      )\n";
    };
    deploy = {
      libraries = ["ansi-terminal" "bytestring" "deepseq" "optparse-applicative" "shh"];
      loadFromBins = ["coreutils" "git" "hostname" "nvd" "openssh"];
      name = "deploy";
      text = "module Main where\n\nimport Control.Applicative ((<**>))\nimport Control.DeepSeq (NFData)\nimport Control.Monad (unless, when)\nimport Data.Bool (bool)\nimport Data.ByteString.Lazy.Char8 (ByteString)\nimport qualified Data.ByteString.Lazy.Char8 as BS\nimport Data.Foldable (traverse_)\nimport Data.Functor (($>))\nimport Data.Maybe (catMaybes)\nimport GHC.Generics (Generic)\nimport qualified GHC.IO.StdHandles as H\nimport qualified Options.Applicative as Opt\nimport Shh\nimport qualified System.Console.ANSI as Ansi\nimport System.Exit (exitFailure)\nimport qualified System.IO as H\n\n$(loadEnv SearchPath)\n\ndata Deploy = Deploy\n  { fast :: Bool\n  , unattended :: Bool\n  , remote :: Bool\n  , target :: ByteString\n  , localhost :: ByteString\n  }\n  deriving stock (Generic)\n\ninstance NFData Deploy\n\nparseDeploy :: ByteString -> Opt.ParserInfo Deploy\nparseDeploy localhost =\n  Opt.info\n    (parser <**> Opt.helper)\n    ( Opt.fullDesc\n        <> Opt.progDesc \"Deploy nix configurations remotely\"\n        <> Opt.header \"depoy nixos configs\"\n    )\n  where\n    parser :: Opt.Parser Deploy\n    parser =\n      Deploy\n        <$> Opt.switch\n          (Opt.long \"fast\" <> Opt.short 'f' <> Opt.help \"Skip evaluating twice but also skip diffs\")\n        <*> Opt.switch\n          (Opt.long \"unattended\" <> Opt.short 'u' <> Opt.help \"Disable asking for confirmation\")\n        <*> Opt.switch\n          (Opt.long \"remote\" <> Opt.short 'r' <> Opt.help \"Run everything on remote. Makes target required\")\n        <*> Opt.strArgument\n          (Opt.value localhost <> Opt.metavar \"target\" <> Opt.help \"Host to deploy to\")\n        <*> pure localhost\n\n-- TODO: investigate using this, probably if/when switching to stand-alone home-manager\n-- nvd \"diff\" \"~/.local/state/nix/profiles/home-manager\" path\nmain :: IO ()\nmain = do\n  localhost <- hostname |> captureTrim\n  (Deploy isFast isUnattended buildRemotely target _) <- Opt.execParser (parseDeploy localhost)\n  let\n    isLocal = target == localhost\n    isMac = target == \"apate\"\n    package = \".#nixosConfigurations.\" <> target <> \".config.system.build.toplevel\"\n    hostPackage = \".#\" <> target\n    sshTarget = mkSshTarget target\n    runSshCwd cmd = ssh sshTarget (\"cd code/dotfiles; \" <> cmd)\n\n  when (isLocal && buildRemotely) do\n    output Ansi.Red \"Cannot build remotely and deploy locally.\\n\"\n    exitFailure\n\n  when (not isLocal && not buildRemotely && isMac) do\n    traverse_\n      (uncurry output)\n      [ (Ansi.Red, \"Cannot locally build for \")\n      , (Ansi.Cyan, \"apate \")\n      , (Ansi.Red, \".\")\n      ]\n    exitFailure\n\n  traverse_ (uncurry output)\n    . catMaybes\n    $ [ Just (Ansi.Magenta, \"-> \")\n      , Just (Ansi.Red, \"deploy \")\n      , Just . bool (Ansi.Green, \"locally \") (Ansi.Red, \"remotely \") $ buildRemotely\n      , Just (Ansi.White, \"for \")\n      , Just (Ansi.Magenta, sshTarget)\n      , Just (Ansi.White, \" \")\n      , bool Nothing (Just (Ansi.Cyan, \"fast \")) isFast\n      , bool Nothing (Just (Ansi.Cyan, \"unattended \")) isUnattended\n      , Just (Ansi.White, \"\\n\\n\")\n      ]\n\n  cd (getDotfilesPath localhost)\n\n  -- Print detailed local git status. This is relevant in all cases:\n  --   - build local, deploying local: dirty local state\n  --   - build local, deploying remote: same\n  --   - remote local: will deploy whatever origin/main is!\n  git \"status\" \"--porcelain\" \"-b\"\n    |> fmap parseGitStatus captureLines\n    >>= gitStatus localhost\n\n  -- 'ssh git pull' for remote builds\n  when buildRemotely do\n    traverse_\n      (uncurry output)\n      [ (Ansi.White, \"[\")\n      , (Ansi.Magenta, sshTarget)\n      , (Ansi.White, \"] git pull\\n\")\n      ]\n    runSshCwd \"git pull\" &> devNull\n    runSshCwd \"git status --porcelain -b\"\n      |> fmap parseGitStatus captureLines\n      >>= gitStatus target\n\n  unless (isFast || isMac) do\n    traverse_\n      (uncurry output)\n      [ (Ansi.White, \"[\")\n      , (Ansi.Magenta, sshTarget)\n      , (Ansi.White, \"] nix build \")\n      , (Ansi.Green, package)\n      , (Ansi.White, \"\\n\")\n      ]\n    path <- case buildRemotely of\n      False -> do\n        exe \"nix\" \"build\" \"--quiet\" \"--quiet\" package &> devNull\n        readlink \"./result\" |> captureTrim\n      True -> do\n        runSshCwd (\"nix build --quiet --quiet \" <> package) &> devNull &!> devNull\n        runSshCwd \"readlink ./result\" |> captureTrim\n\n    case (isLocal, buildRemotely) of\n      (False, False) -> do\n        traverse_\n          (uncurry output)\n          [ (Ansi.White, \"[\")\n          , (Ansi.Magenta, sshTarget)\n          , (Ansi.White, \"] nix copy \")\n          , (Ansi.Green, package)\n          , (Ansi.White, \"\\n\")\n          ]\n        exe \"nix\" \"copy\" \"-L\" package \"--no-check-sigs\" \"--to\" (\"ssh-ng://\" <> sshTarget) &> devNull\n        ssh sshTarget \"nvd\" \"diff\" \"/run/current-system\" path\n      (True, False) ->\n        nvd \"diff\" \"/run/current-system\" path\n      (_, True) ->\n        runSshCwd $ \"nvd diff /run/current-system \" <> path\n\n  shouldUpdate <-\n    if isUnattended\n      then pure True\n      else do\n        traverse_\n          (uncurry output)\n          [ (Ansi.White, \"\\n\")\n          , (Ansi.White, \"[\")\n          , (Ansi.Magenta, sshTarget)\n          , (Ansi.White, \"] start \")\n          , (Ansi.Red, \"deploy \")\n          , (Ansi.White, \"(y/n): \")\n          ]\n        H.hSetBuffering H.stdin H.NoBuffering\n        H.getChar >>= \\case\n          'y' -> output Ansi.White \"\\n\" $> True\n          _ -> output Ansi.White \"\\n\" $> False\n\n  when shouldUpdate do\n    traverse_\n      (uncurry output)\n      [ (Ansi.White, \"[\")\n      , (Ansi.Magenta, sshTarget)\n      , (Ansi.White, \"] \")\n      , (Ansi.Red, \"deploy\")\n      , (Ansi.White, \"ing \")\n      , (Ansi.Green, \".#\" <> target)\n      , (Ansi.White, \" ... \\n\")\n      ]\n    case (isLocal, buildRemotely, isMac) of\n      (True, False, False) -> exe \"sudo\" \"nixos-rebuild\" \"switch\" \"--quiet\" \"--quiet\" \"--flake\" hostPackage\n      (True, False, True) -> exe \"sudo\" \"darwin-rebuild\" \"switch\" \"--flake\" hostPackage\n      (False, True, False) -> runSshCwd $ \"sudo nixos-rebuild switch --quiet --quiet --flake \" <> hostPackage\n      (False, True, True) -> runSshCwd $ \"sudo darwin-rebuild switch --flake \" <> hostPackage\n      _ ->\n        -- the target cannot be macos, so this is always correct.\n        exe\n          \"nixos-rebuild\"\n          \"--quiet\"\n          \"--quiet\"\n          \"--flake\"\n          hostPackage\n          \"--target-host\"\n          sshTarget\n          \"--use-remote-sudo\"\n          \"switch\"\n\nmkPackage :: ByteString -> ByteString\nmkPackage =\n  \\case\n    \"apate\" -> \".#darwinConfigurations.apate\"\n    target -> \".#nixosConfigurations.\" <> target <> \".config.system.build.toplevel\"\n\noutput :: (ExecArg s) => Ansi.Color -> s -> IO ()\noutput color text = do\n  Ansi.setSGR [Ansi.SetColor Ansi.Foreground Ansi.Vivid color]\n  writeOutput text\n\nmkSshTarget :: BS.ByteString -> BS.ByteString\nmkSshTarget =\n  \\case\n    \"arche\" -> \"every@arche\"\n    sshTarget -> \"evie@\" <> sshTarget\n\ngetDotfilesPath :: ByteString -> FilePath\ngetDotfilesPath =\n  \\case\n    \"apate\" -> \"/Users/evie/code/dotfiles\"\n    \"arche\" -> \"/home/every/code/dotfiles\"\n    _ -> \"/home/evie/code/dotfiles\"\n\ngitStatus :: ByteString -> GitStatus -> IO ()\ngitStatus remote =\n  \\case\n    Clean ->\n      traverse_\n        (uncurry output)\n        [ (Ansi.White, \"[\")\n        , (Ansi.Magenta, remote)\n        , (Ansi.White, \":\")\n        , (Ansi.Cyan, BS.pack $ getDotfilesPath remote)\n        , (Ansi.White, \"] git status \")\n        , (Ansi.Green, \"clean\\n\")\n        ]\n    Dirty aheadOrBehind branch xs ->\n      traverse_\n        (uncurry output)\n        [ (Ansi.White, \"[\")\n        , (Ansi.Magenta, remote)\n        , (Ansi.White, \":\")\n        , (Ansi.Cyan, BS.pack $ getDotfilesPath remote)\n        , (Ansi.White, \"] git status \")\n        , (Ansi.Red, \"dirty \")\n        , maybe (Ansi.White, \"\") ((Ansi.Cyan,) . (<> \" \")) branch\n        , maybe (Ansi.White, \"\") (Ansi.Yellow,) aheadOrBehind\n        , bool (Ansi.White, \"\\n\") (Ansi.White, \"\") . null $ xs\n        , (Ansi.Yellow, trim . BS.unlines . fmap trim $ xs)\n        , (Ansi.White, \"\\n\")\n        ]\n\ndata GitStatus = Clean | Dirty (Maybe ByteString) (Maybe ByteString) [ByteString]\n\nparseGitStatus :: [ByteString] -> GitStatus\nparseGitStatus =\n  \\case\n    [] -> error \"Unexpected empty 'git status' output.\"\n    [branchStatus] ->\n      case parseHeader branchStatus of\n        (Nothing, Nothing) -> Clean\n        (aheadOrBehind, branch) -> Dirty aheadOrBehind branch []\n    (branchStatus : rest) ->\n      let\n        (aheadOrBehind, branch) = parseHeader branchStatus\n      in\n        Dirty aheadOrBehind branch rest\n  where\n    parseHeader :: ByteString -> (Maybe ByteString, Maybe ByteString)\n    parseHeader branchStatus =\n      case BS.words branchStatus of\n        [\"##\", \"main...origin/main\"] -> (Nothing, Nothing)\n        [\"##\", br] -> (Nothing, Just br)\n        [\"##\", \"main...origin/main\", \"[ahead\", nr] -> (Just $ BS.dropEnd 1 nr <> \" ahead\", Nothing)\n        [\"##\", \"main...origin/main\", \"[behind\", nr] -> (Just $ BS.dropEnd 1 nr <> \" behind\", Nothing)\n        [\"##\", br, \"[ahead\", nr] -> (Just $ BS.dropEnd 1 nr <> \" ahead\", Just br)\n        [\"##\", br, \"[behind\", nr] -> (Just $ BS.dropEnd 1 nr <> \" behind\", Just br)\n        xs -> error $ \"Unexpected 'git status' header: \" <> show xs\n";
    };
    dotfiles = {
      libraries = ["bytestring" "optparse-applicative" "shh"];
      loadFromBins = ["alejandra" "coreutils" "gnused" "nix"];
      name = "dotfiles";
      text = "module Main where\n\nimport Control.Applicative ((<**>))\nimport Data.ByteString.Lazy.Char8 (ByteString)\nimport qualified Data.ByteString.Lazy.Char8 as BS\nimport Data.Maybe (fromMaybe)\nimport qualified Options.Applicative as Opt\nimport Shh\n\n$(loadEnv SearchPath)\n\ndata Dotfiles\n  = Nix2hs Nix2hsOptions\n  | Hs2nix Hs2NixOptions\n\nnewtype Nix2hsOptions = Nix2hsOptions\n  { name :: ByteString\n  }\n\nnewtype Hs2NixOptions = Hs2NixOptions\n  { name :: ByteString\n  }\nparseNameFor :: (ByteString -> a) -> Opt.Parser a\nparseNameFor ctor = ctor <$> Opt.strArgument (Opt.metavar \"name\" <> Opt.help \"name of the script\")\n\ncommandParser :: Opt.ParserInfo Dotfiles\ncommandParser =\n  Opt.info\n    (parser <**> Opt.helper)\n    ( Opt.fullDesc\n        <> Opt.progDesc \"Dotfiles helper -- see --help for more info\"\n        <> Opt.header \"helps with dotfiles stuff\"\n    )\n  where\n    parser :: Opt.Parser Dotfiles\n    parser =\n      Opt.hsubparser\n        . mconcat\n        $ [ Opt.command\n              \"nix2hs\"\n              ( Opt.info\n                  (Nix2hs <$> parseNameFor Nix2hsOptions)\n                  (Opt.progDesc \"copy script contents from haskell.nix to Main.hs\")\n              )\n          , Opt.command\n              \"hs2nix\"\n              ( Opt.info\n                  (Hs2nix <$> parseNameFor Hs2NixOptions)\n                  (Opt.progDesc \"copy script contents from Main.hs to haskell.nix\")\n              )\n          ]\n\nmain :: IO ()\nmain = do\n  Opt.execParser commandParser >>= \\case\n    Nix2hs opts -> nix2hs opts\n    Hs2nix opts -> hs2nix opts\n\nmainHs :: ByteString\nmainHs = \"/home/evie/code/dotfiles/scripts/dotfiles-script/exe/Main.hs\"\n\nhaskellNix :: ByteString\nhaskellNix = \"/home/evie/code/dotfiles/packages/haskell.nix\"\n\ntmpHaskellNix :: ByteString\ntmpHaskellNix = \"/home/evie/code/dotfiles/packages/haskell-tmp.nix\"\n\nhs2nix :: Hs2NixOptions -> IO ()\nhs2nix Hs2NixOptions {..} = do\n  program <- sed \"-n\" \"/module Main where/,$p\" mainHs |> capture\n  nix \"eval\" \"--file\" haskellNix \"--apply\" (replaceText program)\n    |> exe \"alejandra\" \"--quiet\"\n      &> Truncate tmpHaskellNix\n  mv tmpHaskellNix haskellNix\n  where\n    replaceText :: ByteString -> ByteString\n    replaceText program =\n      mconcat\n        [ \"p: \"\n        , \"let pkgs = import <nixpkgs>{};\"\n        , \"in pkgs.lib.attrsets.recursiveUpdate p {\"\n        , \"programs.\"\n        , name\n        , \".text = \"\n        , orDefault (BS.stripPrefix \"\\\\\\\"\") . orDefault (BS.stripSuffix \"\\\\\\\"\") . BS.pack . show $ program\n        , \";\"\n        , \"}\"\n        ]\n    orDefault :: forall a. (a -> Maybe a) -> a -> a\n    orDefault fn = fromMaybe <*> fn\n\nnix2hs :: Nix2hsOptions -> IO ()\nnix2hs Nix2hsOptions {..} =\n  nix\n    \"eval\"\n    \"--raw\"\n    \"--file\"\n    haskellNix\n    \"--apply\"\n    (\"p: p.haskellLanguagePragmas + \\\"\\n\\\" + p.programs.\" <> name <> \".text\")\n    &> Truncate mainHs\n";
    };
    email-status = {
      libraries = ["aeson" "bytestring" "deepseq" "table-layout" "shh"];
      loadFromBins = ["notmuch"];
      name = "email-status";
      text = "module Main where\n\nimport Control.DeepSeq (NFData)\nimport Data.Aeson ((.=))\nimport qualified Data.Aeson as Aeson\nimport Data.Bool (bool)\nimport Data.ByteString.Lazy.Char8 (ByteString)\nimport qualified Data.ByteString.Lazy.Char8 as LBS\nimport GHC.Generics (Generic)\nimport Shh\nimport qualified System.Environment as Env\nimport qualified Text.Layout.Table as Table\n\n$(loadEnv SearchPath)\n\nmain :: IO ()\nmain = do\n  Env.getArgs >>= \\case\n    [tag] -> run tag\n    _ -> error \"expected a single argument: notmuch tag\"\n\nrun :: String -> IO ()\nrun tag = do\n  let\n    searchTerm = \"tag:\" <> tag\n  count <- notmuch \"count\" searchTerm |> captureTrim\n  emails <-\n    notmuch \"search\" \"--limit=20\" \"--format=json\" searchTerm\n      |> readInput (Aeson.throwDecode @[EmailSummary])\n  printJsonSummary count emails\n\ndata EmailSummary = EmailSummary\n  { date_relative :: String\n  , authors :: String\n  , subject :: String\n  , tags :: [String]\n  }\n  deriving stock (Generic, Show)\n  deriving anyclass (NFData, Aeson.ToJSON, Aeson.FromJSON)\n\nprintJsonSummary :: ByteString -> [EmailSummary] -> IO ()\nprintJsonSummary count emails =\n  writeOutput\n    . Aeson.encode\n    . Aeson.object\n    $ [ \"text\" .= LBS.unpack count\n      , \"alt\" .= \"\"\n      , \"tooltip\" .= bool \"\" (formatTable . fmap formatEmail $ emails) (not $ null emails)\n      , \"class\" .= (bool \"unread\" \"none\" $ count == \"0\")\n      ]\n where\n  formatEmail :: EmailSummary -> [String]\n  formatEmail EmailSummary {..} =\n    [ date_relative\n    , authors\n    , subject\n    , unwords tags\n    ]\n\n  formatTable :: [[String]] -> String\n  formatTable =\n    fmap replaceNewline\n      . Table.tableString\n      . Table.headerlessTableS\n        [Table.def, Table.def, Table.def, Table.def]\n        Table.unicodeRoundS\n      . fmap Table.rowG\n\n  replaceNewline :: Char -> Char\n  replaceNewline = \\case\n    '\\n' -> '\\r'\n    c -> c\n";
    };
    hyprshade-ctl = {
      libraries = ["aeson" "bytestring" "text" "shh"];
      loadFromBins = ["hyprshade"];
      name = "hyprshade-ctl";
      text = "module Main where\n\nimport Data.Aeson ((.=))\nimport qualified Data.Aeson as Aeson\nimport Data.Bool (bool)\nimport Data.ByteString.Lazy (ByteString)\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport qualified Data.Text.Lazy as TL\nimport qualified Data.Text.Lazy.Encoding as TL\nimport Shh\nimport qualified System.Environment as Env\n\n$(loadEnv SearchPath)\n\nmain :: IO ()\nmain = do\n  Env.getArgs >>= \\case\n    [\"status\"] -> hyprshade \"current\" |> readInputLines (status)\n    [\"toggle\"] -> hyprshade \"toggle\" \"blue-light-filter\"\n    [msg] -> error $ \"unexpected command: \" <> msg\n    _ -> error \"expected a single argument\"\n\nstatus :: [ByteString] -> IO ()\nstatus bs =\n  writeOutput\n    . Aeson.encode\n    . Aeson.object\n    $ [ \"text\" .= \"\"\n      , \"alt\" .= bool \"off\" \"on\" hasAnyFilter\n      , \"tooltip\" .= (TL.strip . TL.decodeUtf8 . BSL.unlines $ bs)\n      , \"class\" .= bool \"disabled\" \"enabled\" hasAnyFilter\n      ]\n    where\n      hasAnyFilter :: Bool\n      hasAnyFilter = bs /= []\n";
    };
    webcam-status = {
      libraries = ["aeson" "bytestring" "deepseq" "extra" "filepath" "shh"];
      loadFromBins = ["coreutils"];
      name = "webcam-status";
      text = "module Main where\n\nimport Control.DeepSeq (NFData)\nimport Data.Aeson ((.=))\nimport qualified Data.Aeson as Aeson\nimport Data.Bool (bool)\nimport Data.ByteString.Lazy (ByteString)\nimport qualified Data.ByteString.Lazy.Char8 as BS\nimport Data.List.Extra (nubOrdOn)\nimport GHC.Generics (Generic)\nimport Shh\nimport System.FilePath ((</>))\n\n$(loadEnv SearchPath)\n\ndeviceRoot, runtimeEnabled, runtimeStatus, cameraIcon :: String\ndeviceRoot = \"/sys/class/video4linux\"\nruntimeEnabled = \"device/power/runtime_enabled\"\nruntimeStatus = \"device/power/runtime_status\"\ncameraIcon = \"\\61488\"\n\nmain :: IO ()\nmain =\n  ls deviceRoot\n    |> readInputLinesP (traverse getDeviceInfo)\n    >>= printJsonSummary . nubOrdOn name\n\ndata DeviceInfo = DeviceInfo\n  { name :: String\n  , enabled :: Bool\n  , active :: Bool\n  }\n  deriving stock (Generic, Eq, Ord, Show)\n  deriving anyclass (Aeson.ToJSON, NFData)\n\ngetDeviceInfo :: ByteString -> Proc DeviceInfo\ngetDeviceInfo videoDevice = do\n  let\n    root = deviceRoot </> BS.unpack videoDevice\n  name <- cat (root </> \"name\") |> readInput (pure . BS.unpack . trim)\n  enabled <- cat (root </> runtimeEnabled) |> readInput (pure . (== \"enabled\") . trim)\n  active <- cat (root </> runtimeStatus) |> readInput (pure . (== \"active\") . trim)\n  pure DeviceInfo {..}\n\nprintJsonSummary :: [DeviceInfo] -> IO ()\nprintJsonSummary devices =\n  writeOutput\n    . Aeson.encode\n    . Aeson.object\n    $ [ \"text\" .= cameraIcon\n      , \"alt\" .= \"\"\n      , \"tooltip\" .= (unlines . fmap formatDevice $ devices)\n      , \"class\"\n          .= if any active devices\n            then \"active\"\n            else bool \"none\" \"enabled\" . any enabled $ devices\n      ]\n where\n  formatDevice :: DeviceInfo -> String\n  formatDevice DeviceInfo {..} =\n    unwords\n      [ cameraIcon\n      , name\n      , bool \"disabled\" \"enabled\" enabled\n      , bool \"active\" \"suspended\" active\n      ]\n";
    };
  };
}
